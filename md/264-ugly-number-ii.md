### Leetcode 264 (Medium): Ugly Number II [Practice](https://leetcode.com/problems/ugly-number-ii)

### Description  
Given an integer `n`, find the nᵗʰ **ugly number**.  
An ugly number is a positive integer whose prime factors are only **2, 3, or 5**.  
For this sequence:  
- The **first ugly number is 1**.
- Every next ugly number is the smallest integer greater than the previous ugly number and can be formed by multiplying any ugly number before it by 2, 3, or 5 (duplicates must be avoided).

Your goal: Return the nᵗʰ ugly number.

### Examples  

**Example 1:**  
Input: `n = 10`  
Output: `12`  
*Explanation: The first 10 ugly numbers are: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12. The 10ᵗʰ is 12.*

**Example 2:**  
Input: `n = 1`  
Output: `1`  
*Explanation: By definition, 1 is considered the first ugly number.*

**Example 3:**  
Input: `n = 15`  
Output: `24`  
*Explanation: The first 15 ugly numbers are: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24. The 15ᵗʰ is 24.*



### Thought Process (as if you’re the interviewee)  

Let’s clarify the brute-force approach first:  
- Check every number one-by-one, see if its only prime factors are 2, 3, or 5.  
- For each, divide out all factors of 2, then 3, then 5. If result is 1, it’s ugly.
- But for large n (e.g., n=10000), this is **too slow**—need a better solution!

Optimized approach:  
- Notice every new ugly number can be generated by multiplying a previous ugly number by 2, 3, or 5.
- Maintain an array `dp` of ugly numbers in order; start with 1 at index 0.
- Keep three pointers:  
  p₂ → next ugly number to multiply by 2  
  p₃ → next ugly number to multiply by 3  
  p₅ → next ugly number to multiply by 5  
- At each step, pick the minimum of (dp[p₂] × 2, dp[p₃] × 3, dp[p₅] × 5) as the next ugly number.
- Move forward any pointer whose product matched the chosen value (so if duplicate values occur, bump all pointers involved).
- Repeat n-1 times to fill in the list.

This process **avoids duplicates** and generates only valid ugly numbers, efficiently in order[1][2][3].

(Min-heap can also be used, but pointer method is more optimal for this exact problem.)



### Corner cases to consider  
- n = 1 (should return 1 immediately)
- Large n (e.g., n = 10,000)
- Avoiding duplicates (don’t add the same ugly number more than once)
- Memory constraints (ensure storage proportionate to n)
- Avoid integer overflow (if programming language has int limits)



### Solution

```python
def nthUglyNumber(n):
    # Initialize ugly numbers list
    dp = [1] * n
    # Three pointers for multiples of 2, 3, 5
    p2 = p3 = p5 = 0

    for i in range(1, n):
        next2 = dp[p2] * 2
        next3 = dp[p3] * 3
        next5 = dp[p5] * 5
        # Choose the smallest next value
        dp[i] = min(next2, next3, next5)
        # Advance pointers for whichever matched
        if dp[i] == next2:
            p2 += 1
        if dp[i] == next3:
            p3 += 1
        if dp[i] == next5:
            p5 += 1

    return dp[-1]
```

### Time and Space complexity Analysis  

- **Time Complexity:** O(n).
  - Each loop step does constant work; we only look at and update pointers and arrays of size n.
- **Space Complexity:** O(n).
  - We store a list of size n for ugly numbers, plus three integer pointers.

### Potential follow-up questions (as if you’re the interviewer)  

- Can you generate numbers with other prime factors (e.g., only 3 and 7)?
  *Hint: Parameterize the prime list; logic adapts with multiple pointers—generalize the implementation.*

- How would you return the sequence up to the nᵗʰ ugly number, not just the nth?
  *Hint: You already have it in the dp array. Just return the dp list.*

- What if you cared about the largest ugly number ≤ k?
  *Hint: Stop generation early as soon as the next value would exceed k.*


### Summary
This problem demonstrates a classic **Dynamic Programming + Multiple Pointers** pattern, also known as the "merge k sorted lists" technique.  
- We build up the solution using previously computed values and avoid brute-force checking.  
- This pattern appears in problems like generating super ugly numbers, merging sorted arrays, or other number sequence building blocks.  
- Main takeaways: Use pointers to avoid duplicates and ensure sorted order.