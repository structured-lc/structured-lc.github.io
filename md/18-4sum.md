### Leetcode 18 (Medium): 4Sum [Practice](https://leetcode.com/problems/4sum)

### Description  
Given an integer array, the task is to find all **unique quadruplets** (a set of four numbers) in the array such that their sum is equal to a specified target. Each quadruplet consists of four integers from the array (indices must be distinct, i.e., a < b < c < d), and you must not return duplicate quadruplets regardless of their order. This problem is an extension of 2Sum and 3Sum, and often involves sorting and scanning in a systematic way.

### Examples  

**Example 1:**  
Input: `nums = [1, 0, -1, 0, -2, 2]`, `target = 0`  
Output: `[[-2, -1, 1, 2], [-2, 0, 0, 2], [-1, 0, 0, 1]]`  
*Explanation: All these quadruplets sum to 0. No duplicate quadruplets are included, and order within quadruplet does not matter.*

**Example 2:**  
Input: `nums = [2, 2, 2, 2, 2]`, `target = 8`  
Output: `[[2, 2, 2, 2]]`  
*Explanation: Only one quadruplet can be formed by picking all 2s, which sums to 8.*

**Example 3:**  
Input: `nums = [0, 0, 0, 0]`, `target = 1`  
Output: `[]`  
*Explanation: All elements sum to 0, which is not equal to 1, so no quadruplets are possible.*


### Thought Process (as if you’re the interviewee)  
- **Brute-force:**  
  - Try all possible quadruplets (4 nested loops).  
  - Time: O(n⁴), space: O(1) or O(# results).  
  - Not feasible for large n due to time complexity.
- **Optimized (Sorting + Two Pointers):**  
  - Sort the array.  
  - Use two fixed indices (`i`, `j`) and two pointers (`left`, `right`) for the remaining elements.
  - Skip duplicates at each loop level to ensure uniqueness.
  - For each pair (`i`,`j`), use two-pointer logic like 2Sum to find possible pairs that achieve the target minus nums[i] and nums[j].
  - Time: O(n³), much better.
- **Further optimization/generic:**  
  - Design a recursive K-Sum routine, so it works for arbitrary k (e.g., for interview extensions to FiveSum, etc.).  
  - For 4Sum specifically, the above two-pointer approach is sufficient and the most readable.

### Corner cases to consider  
- Empty array or array has < 4 elements.
- Multiple identical elements.
- No quadruplets sum to the target.
- All elements are the same, e.g., `[0,0,0,0,0]`, target 0.
- Negative, zero, and positive elements mixed.

### Solution

```python
def fourSum(nums, target):
    nums.sort()
    n = len(nums)
    result = []
    
    # Loop for the first element
    for i in range(n - 3):
        # Skip duplicates for first position
        if i > 0 and nums[i] == nums[i - 1]:
            continue

        # Loop for the second element
        for j in range(i + 1, n - 2):
            # Skip duplicates for second position
            if j > i + 1 and nums[j] == nums[j - 1]:
                continue

            left = j + 1
            right = n - 1

            while left < right:
                s = nums[i] + nums[j] + nums[left] + nums[right]
                if s == target:
                    result.append([nums[i], nums[j], nums[left], nums[right]])
                    # Skip all duplicates for third and fourth positions
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1
                    left += 1
                    right -= 1
                elif s < target:
                    left += 1
                else:
                    right -= 1
    return result
```

### Time and Space complexity Analysis  

- **Time Complexity:** O(n³), where n is the length of nums.  
  The outer two loops are O(n²), and the two-pointer scan for each pair is O(n), leading to O(n³) in total.
- **Space Complexity:** O(1) additional space (ignoring output storage), as we sort in place and use only pointers and variables. The result list can be at most O(n³) in the worst case, for all unique quadruplets.

### Potential follow-up questions (as if you’re the interviewer)  

- How would you generalize this solution for k-Sum (e.g., 5 numbers summing to target)?
  *Hint: Think about recursive design and base cases like 2Sum using two pointers.*

- Can you solve this if the array is **not allowed to be sorted**?
  *Hint: Would involve hash sets, but duplicate removal becomes complex.*

- How would your solution change if negative numbers are not allowed or all input numbers are guaranteed to be positive?
  *Hint: Can you use early stopping based on sorted order or break out of loops early?*


### Summary
The main approach is sorting the array and using fixed & moving pointers to efficiently scan for quadruplets, following patterns familiar from 2Sum and 3Sum but with an extra loop. Handling duplicates at every loop level is essential for uniqueness. This "Sort + Two Pointers" pattern is common for k-Sum family problems, and a recursive version can generalize to arbitrary k. It's broadly applicable for other subset-sum-type problems—useful to master for interviews.

### Tags
Array(#array), Two Pointers(#two-pointers), Sorting(#sorting)

### Similar Problems
- Two Sum(two-sum) (Easy)
- 3Sum(3sum) (Medium)
- 4Sum II(4sum-ii) (Medium)
- Count Special Quadruplets(count-special-quadruplets) (Easy)