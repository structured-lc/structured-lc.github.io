### Leetcode 924 (Hard): Minimize Malware Spread [Practice](https://leetcode.com/problems/minimize-malware-spread)

### Description  
We are given a network of n nodes represented by an n × n adjacency matrix graph, where graph[i][j] = 1 indicates node i is directly connected to node j. Some nodes (listed in the array initial) are initially infected with malware. A node becomes infected either because it's initially infected or because it has a direct or indirect connection (through infected nodes) to other infected nodes. The malware spreads across the network as long as at least one node in a direct connection is infected.  
Our task: Remove one node from the initial infected list to minimize the final number of infected nodes after the malware stops spreading. If multiple solutions are possible, pick the node with the smallest index.

### Examples  

**Example 1:**  
Input:  
`graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]`  
Output: `0`  
Explanation:  
Nodes 0 and 1 are connected, forming one component, and node 2 is isolated. If you remove node 0 (from initial), node 1 is still infected and the component still gets infected, but as per the smallest index rule, we return 0.

**Example 2:**  
Input:  
`graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]`  
Output: `0`  
Explanation:  
Each node is isolated (no edges). Initial nodes are 0 and 2. Removing either reduces infection count by just 1, but we pick the smaller index, which is 0.

**Example 3:**  
Input:  
`graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]`  
Output: `1`  
Explanation:  
All nodes are interconnected. If you remove node 1, node 2 remains infected and can infect all others, so no actual reduction. Since both result in the same infected count, we choose the smaller index, which is 1.

### Thought Process (as if you’re the interviewee)  
- **Brute-force approach:**  
  For each node in initial, try removing it, simulate malware spread, and record the total number of infected nodes after spread. This works but is very slow (exponential time for n up to 300).
- **Key optimization:**  
  The malware spreads within connected components. If a component has only one initial infection, removing that infection saves the whole component from infection.  
  - Identify all connected components (Union Find or DFS).
  - For each component, count the initial infected nodes within it.
  - For each node in initial, if it’s the *only* infected node in its component, then removing it prevents the component from getting infected (saves the whole component size).
  - Among candidates, pick the one that saves the most nodes, with tie-breaker on smallest index.
- **Why best:**  
  - Drastically reduces work from simulating infection for every removal to component analysis.  
  - Union Find has near-linear time with path compression.

### Corner cases to consider  
- All nodes in initial are from different components.
- All nodes in initial are from the same component.
- The graph is fully disconnected (all diagonal 1, off-diagonal 0).
- The graph is fully connected (complete graph).
- initial has size 1.
- Multiple nodes in initial belong to same component.
- More than one node yields the same saved count (test tie-breaking by index).

### Solution

```python
def minMalwareSpread(graph, initial):
    n = len(graph)
    parent = [i for i in range(n)]
    
    # Union Find: find with path compression
    def find(u):
        if parent[u] != u:
            parent[u] = find(parent[u])
        return parent[u]

    # Union Find: union by root
    def union(u, v):
        ru, rv = find(u), find(v)
        if ru != rv:
            parent[rv] = ru

    # Build connected components
    for i in range(n):
        for j in range(n):
            if graph[i][j]:
                union(i, j)

    # Count size of each component
    size = [0] * n
    for node in range(n):
        root = find(node)
        size[root] += 1

    # For each component, count # of initial nodes inside
    infected = [0] * n
    for node in initial:
        root = find(node)
        infected[root] += 1

    ans = None
    max_saved = -1

    for node in sorted(initial):
        root = find(node)
        # Only if node is the only initial in its component
        if infected[root] == 1:
            saved = size[root]
            if saved > max_saved or (saved == max_saved and node < ans):
                ans = node
                max_saved = saved

    # If no node can save any component, return min(initial)
    return ans if ans is not None else min(initial)
```

### Time and Space complexity Analysis  

- **Time Complexity:** O(n²) primarily due to the double loop to build unions (since the graph is an adjacency matrix). All other steps (counting, scanning) are O(n).
- **Space Complexity:** O(n) for Union Find parent, sizes, and counts.

### Potential follow-up questions (as if you’re the interviewer)  

- How would you adapt if the graph is given as an edge list instead of an adjacency matrix?  
  *Hint: Build adjacency lists, Union Find needs only pairs of nodes.*

- What if you needed to remove k nodes, not just one, to minimize spread?  
  *Hint: Try all combinations, or use a greedy or DP strategy for up to k.*

- Can you solve this problem efficiently on a streaming graph (edges arrive one by one)?  
  *Hint: Need dynamic or online algorithms for connected components.*

### Summary
This approach leverages the **Union Find (Disjoint Set Union)** pattern to identify connected components in the network, and applies counting logic to figure out which initial node is most impactful to remove. This pattern is common in isolate-and-analyze graph infection/spread/containment problems, and is especially useful for efficiently grouping related nodes in undirected networks.