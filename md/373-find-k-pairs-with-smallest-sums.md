### Leetcode 373 (Medium): Find K Pairs with Smallest Sums [Practice](https://leetcode.com/problems/find-k-pairs-with-smallest-sums)

### Description  
Given two **sorted** arrays (**nums1** and **nums2**) and an integer **k**, find the k pairs `[u, v]` (with `u` from nums1 and `v` from nums2) whose sums are the smallest among all possible pairs. The answer should contain exactly **k** pairs (or fewer if not enough combinations exist).  
Both arrays are sorted in non-decreasing order, so we should leverage that for efficiency.

### Examples  

**Example 1:**  
Input: `nums1 = [1,7,11]`, `nums2 = [2,4,6]`, `k = 3`  
Output: `[[1,2],[1,4],[1,6]]`  
*Explanation:*
- Pair sums: 1+2=3, 1+4=5, 1+6=7, 7+2=9, 7+4=11, 7+6=13, 11+2=13, 11+4=15, 11+6=17
- 3 smallest: [1,2] (3), [1,4] (5), [1,6] (7)

**Example 2:**  
Input: `nums1 = [1,1,2]`, `nums2 = [1,2,3]`, `k = 2`  
Output: `[[1,1],[1,1]]`  
*Explanation:*
- Smallest pairs: [1,1] (from both 1s in nums1 with first 1 in nums2)

**Example 3:**  
Input: `nums1 = [1,2]`, `nums2 = [3]`, `k = 3`  
Output: `[[1,3],[2,3]]`  
*Explanation:*
- Only possible pairs: [1,3], [2,3]; cannot provide 3 pairs, only 2 possible.


### Thought Process (as if you’re the interviewee)  
- **Brute-force**: Try all n×m pairs (n = len(nums1), m = len(nums2)), calculate all sums, sort them, pick k smallest.
    - Drawbacks: O(n×m) space and time, which is too slow for large arrays.

- **Optimization**:
    - Since the arrays are sorted, the smallest pairs will involve the smallest elements from each array.
    - Use a **min-heap** to always pick the next smallest sum efficiently.
        - Start with all pairs (i,0) for i in 0...min(k, len(nums1)), since adding anything from nums2 will be smallest for each nums1.
        - Keep track of indices so that for a popped (i,j), next candidate is (i,j+1). Push only as needed to explore the next smallest sum.

- **Why min-heap approach?**
    - We never create all n×m pairs.
    - Each heap operation is O(log k), and we do at most k insertions/pops.

**Trade-offs:**  
- Uses extra space for the heap and to avoid revisiting pairs, but space is limited by k.
- Much faster for large input sizes with small k.


### Corner cases to consider  
- Any array is empty ⇒ result is empty.
- k larger than total pairs ⇒ return all possible pairs.
- nums1 or nums2 has duplicates.
- k = 0 ⇒ return empty list.
- Both arrays contain identical numbers.
- Both arrays of size 1.


### Solution

```python
import heapq

def k_smallest_pairs(nums1, nums2, k):
    # Corner case: If any array is empty or k is 0, return an empty list
    if not nums1 or not nums2 or k == 0:
        return []

    # Result array for final pairs
    result = []

    # Initialize min-heap; store (sum, i, j): 
    # i: index in nums1, j: index in nums2
    # Only use up to min(k, len(nums1)) to avoid unnecessary heap growth
    heap = []
    for i in range(min(k, len(nums1))):
        heapq.heappush(heap, (nums1[i] + nums2[0], i, 0))
    
    # Extract the k smallest pairs
    while heap and len(result) < k:
        curr_sum, i, j = heapq.heappop(heap)
        # Add the pair to result
        result.append([nums1[i], nums2[j]])
        # If possible, add next pair formed with nums1[i] and nums2[j+1]
        if j + 1 < len(nums2):
            heapq.heappush(heap, (nums1[i] + nums2[j+1], i, j+1))
    
    return result
```

### Time and Space complexity Analysis  

- **Time Complexity:**  
  O(k log k):  
  - At most k heap pops, each push/pop is O(log k).
  - We only ever put up to min(k, len(nums1)) pairs in the heap at start, and may push up to k additional items.

- **Space Complexity:**  
  O(k):  
  - The heap never has more than k elements.
  - Result array stores up to k pairs.


### Potential follow-up questions (as if you’re the interviewer)  

- What if the arrays aren’t sorted?
  *Hint: Can you still optimize or do you need to check all pairs?*

- Can you solve it without extra heap/priority queue, or reduce space further?
  *Hint: Is there an O(k) or in-place strategy? How does the heap help?*

- If asked for kᵗʰ smallest sum only, not all pairs, how would you do it?
  *Hint: Use heap and count pops; what's the kᵗʰ pop?*

### Summary
The main idea uses the **"k-way merge"** or **min-heap / best-first search** pattern, which efficiently finds the k smallest values generated by combining two sorted inputs. It's commonly applied in problems involving merging sorted structures, and is a common interview pattern (e.g., merging k sorted lists, median in sorted arrays, or skyline problems).