### Leetcode 928 (Hard): Minimize Malware Spread II [Practice](https://leetcode.com/problems/minimize-malware-spread-ii)

### Description  
Given a graph where nodes represent computers and edges represent direct connections, some nodes are initially infected with malware. When malware spreads, it contaminates the entire connected component of any infected node. You are allowed to remove one node (and its connections) from the list of initially infected nodes before the spread happens. **Return the node whose removal minimizes the total final number of infected nodes**. If multiple such nodes exist, return the one with the smallest index.

The challenge is to find which infected node's removal results in the smallest total post-infection. When a node is removed, its component may split, potentially "saving" some nodes from infection if those nodes would otherwise only be infected via this one node.

### Examples  

**Example 1:**  
Input: `graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]`  
Output: `0`  
*Explanation: If you remove node 0, node 1 is no longer connected to node 2, so only node 1 stays infected. If you remove node 1, node 0 is still infected and spreads to itself, leaving the same result. Return the smallest index: 0.*

**Example 2:**  
Input: `graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]`  
Output: `0`  
*Explanation: Both node 0 and node 2 are in their own components. Removing either will save 1 node, but 0 is the smallest index.*

**Example 3:**  
Input: `graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]`  
Output: `1`  
*Explanation: Both nodes are in the same component. Removing either will still infect everyone, but 1 is the smallest index.*

### Thought Process (as if you’re the interviewee)  

Start with **brute-force**: For each infected node, try removing it, simulate the spread, and count remaining infected. Pick the removal that minimizes the total, breaking ties with smallest index.

However, simulating spread for each node could be inefficient. To optimize:
- Identify **connected components** in the graph (using DFS/BFS), since infection spreads throughout components.
- For each component, track:
  - Which infected nodes are in it.
  - How many nodes belong to it.
- If a component contains exactly one infected node (from initial), removing it will "save" every other node in that component.
- So, for each initial node, compute how many nodes it could "save" by being removed (only if it's the unique infected node in its component).
- Return the node whose removal saves the most nodes. If tie, return the lowest index.

This uses:
- Component finding: DFS/BFS.
- For each initial node: efficient checking, no simulation required.

### Corner cases to consider  
- No nodes to remove: `initial` is empty.
- Graph has only one node.
- All infected nodes are within the same component.
- Initial list contains all nodes of a single component.
- Initial list contains duplicate nodes.
- Multiple removal options save same number of nodes; choose lowest index.

### Solution

```python
def minMalwareSpread(graph, initial):
    # First, sort initial for tie-breaking by index
    initial = sorted(initial)
    n = len(graph)
    visited = [False] * n
    components = []
    node_to_comp = [None] * n

    # Step 1: Find all connected components and map node → component
    def dfs(u, comp_index):
        stack = [u]
        while stack:
            curr = stack.pop()
            if not visited[curr]:
                visited[curr] = True
                node_to_comp[curr] = comp_index
                components[comp_index].append(curr)
                for v in range(n):
                    if graph[curr][v] == 1 and not visited[v]:
                        stack.append(v)

    for i in range(n):
        if not visited[i]:
            components.append([])
            dfs(i, len(components) - 1)

    # Step 2: For each component, count infected nodes from initial
    comp_infected = [0] * len(components)
    for node in initial:
        comp_id = node_to_comp[node]
        comp_infected[comp_id] += 1

    # Step 3: For each initial node, if it's the sole source in its component, compute its saving
    best_save = -1
    answer = initial[0]
    for node in initial:
        comp_id = node_to_comp[node]
        if comp_infected[comp_id] == 1:
            saved = len(components[comp_id]) - 1   # removing this node: saves others in component
            if saved > best_save or (saved == best_save and node < answer):
                best_save = saved
                answer = node

    # If no such node exists, just return minimal index
    return answer
```

### Time and Space complexity Analysis  

- **Time Complexity:** O(n²), since building the component groups via DFS/BFS takes O(n²) for adjacency matrix, and checking infected/initial nodes is O(n).
- **Space Complexity:** O(n) for visited, node_to_comp arrays, and to track components (at most n nodes total).

### Potential follow-up questions (as if you’re the interviewer)  

- If the graph is extremely large and sparse, how would you improve the component finding step?  
  *Hint: Use adjacency lists instead of adjacency matrix for efficiency.*

- What if you can remove more than one node from the initial list?  
  *Hint: Try greedy or dynamic programming, but becomes NP-hard for k > 1 in general graphs.*

- What if the initial list could have repeated entries or included non-infected nodes?  
  *Hint: Normalize initial (remove duplicates, filter valid infected nodes).*

### Summary
This problem uses the **connected components** pattern in graphs. By grouping nodes and analyzing infected entries per component, you optimize what would otherwise be a brute-force simulation. Recognizing **unique-infection components** and removing their only infected node is the key insight—an approach common in graph infection, network security, and virus containment scenarios.