### Leetcode 679 (Hard): 24 Game [Practice](https://leetcode.com/problems/24-game)

### Description  
Given **an array of four integers** (each between 1 and 9), determine if you can use **each number exactly once** along with the operators **+, -, ×, ÷** and any grouping/parentheses to form the number **24**.  
- **You must use all four numbers, with each used once.**  
- Operators can be used as many times as needed.
- **Division is real division** (not integer), so fractional results are allowed.
- Avoid division by zero.
- The result should be considered correct if it's **within 0.1** of 24 to account for floating-point errors.
- Return `True` if possible, otherwise `False`.

### Examples  

**Example 1:**  
Input: `[4,1,8,7]`  
Output: `True`  
*Explanation: (8 × 7 - 4) ÷ 1 = 52 ÷ 1 = 52; but that's 52. The actual correct path is (8 - 4) × (7 - 1) = 4 × 6 = 24.*

**Example 2:**  
Input: `[1,2,1,2]`  
Output: `False`  
*Explanation: No combination of operations and parentheses produces 24.*

**Example 3:**  
Input: `[3,3,8,8]`  
Output: `True`  
*Explanation: (8 ÷ (3 - 8/3)) = (8 ÷ (3 - 2.666...)) = (8 ÷ 0.333...) = 24.*

### Thought Process (as if you’re the interviewee)  
With only four numbers and four operations, brute force is feasible. There are multiple ways to parenthesize and combine numbers.  
- Idea: **Try all permutations of numbers**, and for each ordering, try all ways of grouping/pairing using the four operations, recursively reducing the possible numbers by one at each step.
- Use **backtracking**: For each pair of numbers, apply all four ops, replace the pair with the result, and recurse. Continue until one number left; check if it's close enough to 24.
- Need to handle edge cases:  
  - Avoid division by zero.
  - Floating-point rounding is managed by using a small epsilon.
- Why not use memoization? Number of states is small for 4 numbers, so brute-force is fast and simple.

### Corner cases to consider  
- Two or more numbers are the same (need to avoid reusing indices improperly).
- Operations like division resulting in zero or negative.
- Precision issues when dividing (floating errors).
- Cases where not all numbers need to be used (not allowed).
- Division by zero.
- Multiple solutions for the same set (just need one).

### Solution

```python
def judgePoint24(nums):
    EPS = 1e-6  # Tolerance for floating point comparison
    
    def search(nums):
        # If only one number left, check if it's 24
        if len(nums) == 1:
            return abs(nums[0] - 24) < 0.1
        
        # Try every possible pair
        for i in range(len(nums)):
            for j in range(len(nums)):
                if i == j:
                    continue
                # Pick two numbers at index i and j
                n1, n2 = nums[i], nums[j]
                # Form a new list without i and j
                next_nums = []
                for k in range(len(nums)):
                    if k != i and k != j:
                        next_nums.append(nums[k])
                
                # Try all possible operations (+, -, ×, ÷)
                for result in [
                    n1 + n2,
                    n1 - n2,
                    n2 - n1,
                    n1 * n2,
                ]:
                    # For multiplication/addition, order doesn't matter
                    # For subtraction/division, try both orders
                    if search(next_nums + [result]):
                        return True

                # For division, check denominator is not 0
                if abs(n2) > EPS and search(next_nums + [n1 / n2]):
                    return True
                if abs(n1) > EPS and search(next_nums + [n2 / n1]):
                    return True
        return False
    # Convert input to floats to handle division
    return search([float(x) for x in nums])
```

### Time and Space complexity Analysis  

- **Time Complexity:** Roughly O(4! × 4⁴) = O(768)  
  We try all pairings, all orders, and all operations but the maximum recursion depth and input size are fixed and small.
- **Space Complexity:** O(1) extra (except recursion stack), because at each step we shrink the list by 1 and depth is ≤4.

### Potential follow-up questions (as if you’re the interviewer)  

- What if the input array has more or fewer than 4 numbers?  
  *Hint: Think about the combinatorial explosion as size increases. Could you generalize the approach?*

- Could you print the actual expression(s) that achieve 24, not just return True/False?  
  *Hint: Store the string representation at each step of recursion along with its value.*

- What if some operators (like ÷) aren't allowed? How would you adjust?  
  *Hint: Just skip the operation(s) in your loop as necessary.*

### Summary
This is a classic **backtracking recursive search** problem, exploiting small fixed input size and exploring all combinations of numbers and operations.  
The same pattern is used in games/puzzles and in problems involving combinatorial generation with constraints, such as making a target sum with operators or evaluating all ways to combine operands.

### Tags
Array(#array), Math(#math), Backtracking(#backtracking)

### Similar Problems
