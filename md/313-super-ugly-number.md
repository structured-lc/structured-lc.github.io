### Leetcode 313 (Medium): Super Ugly Number [Practice](https://leetcode.com/problems/super-ugly-number)

### Description  
Given an integer n and a list of distinct prime numbers, `primes`, find the nᵗʰ super ugly number. A **super ugly number** is a positive integer whose only prime factors are all in the array `primes`. The sequence starts with 1 by definition, and every next super ugly number can be made by multiplying some (possibly repeated) element from an earlier position in the sequence by one of the given primes. Output the nᵗʰ number in this sequence (where n=1 refers to 1).

### Examples  

**Example 1:**  
Input: `n = 12, primes = [2, 7, 13, 19]`  
Output: `32`  
*Explanation: The sequence is [1, 2, 4, 7, 8, 13, 14, 16, 19, 26, 28, 32]. The 12ᵗʰ number is 32.*

**Example 2:**  
Input: `n = 1, primes = [2, 3, 5]`  
Output: `1`  
*Explanation: By definition, the first super ugly number is always 1.*

**Example 3:**  
Input: `n = 5, primes = [2, 3]`  
Output: `6`  
*Explanation: The sequence is [1, 2, 3, 4, 6]. The 5ᵗʰ number is 6.*

### Thought Process (as if you’re the interviewee)  
- **Brute-force:**  
  Initially, one might try to increment every number starting from 1 and check if its prime factors are all within `primes`. This is very slow, especially since each check is O(log N) and we'd check potentially huge numbers to find the sequence up to n.
- **Optimized dynamic programming (DP) / Multiple Pointers:**  
  Recognize that every super ugly number is generated by multiplying any earlier super ugly number with any prime in `primes`.  
  - We maintain an array `ugly` to keep the list, always in sorted order.
  - For each prime, we track an index into `ugly`. Initialize an array `idx` with all zeros (pointing to the first `ugly`).
  - For each position in `ugly`, the next super ugly candidate is `primes[j] × ugly[idx[j]]` for each j.
  - Take the minimum as the next super ugly number, and increment all indices which contributed that number.
- **Why this is efficient:**  
  This generates each new value in sorted order, O(n × k) time, which is feasible for n up to 10⁵ and k up to 100.

### Corner cases to consider  
- n = 1 (should always return 1)
- All primes are large (e.g., ) — make sure the sequence is correctly built.
- Duplicate resulting candidates (e.g., two primes produce the same value in the same round), so need to avoid duplicates in the output list.
- Very large n, small primes (test for performance).
- primes being [2] only.

### Solution

```python
def nthSuperUglyNumber(n, primes):
    # List to store the sequence, first number always 1
    ugly = [1]
    # Each prime has a pointer to where its next multiplied value will come from
    idx = [0] * len(primes)
    # Precompute next multiples for all primes
    next_vals = [primes[i] * ugly[idx[i]] for i in range(len(primes))]
    
    for _ in range(1, n):
        # Next ugly number is the minimum of all candidates
        next_ugly = min(next_vals)
        ugly.append(next_ugly)
        # Advance all pointers whose candidate is the current minimum
        for j in range(len(primes)):
            if next_vals[j] == next_ugly:
                idx[j] += 1
                next_vals[j] = primes[j] * ugly[idx[j]]
    return ugly[-1]
```

### Time and Space complexity Analysis  

- **Time Complexity:** O(n × k), where n is the position to reach and k is the number of primes. For each step, we check all k candidates to find the minimum and update.
- **Space Complexity:** O(n + k): O(n) for the ugly number list, and O(k) for the pointers and next values.

### Potential follow-up questions (as if you’re the interviewer)  

- What if the list of primes is very large?  
  *Hint: Can you optimize candidate selection with a heap or priority queue?*

- Could you return the sequence up to the nᵗʰ super ugly number, not just the nᵗʰ entry?  
  *Hint: Just return the `ugly` list instead of `ugly[-1]`.*

- How would you efficiently handle duplicates, especially when more than one prime/product reaches the minimum at the same time?  
  *Hint: Ensure all pointers for those primes advance, to avoid repeated values in output.*

### Summary
This is a classic application of the multiple-pointers and dynamic programming pattern, generalizing the Ugly Number II approach. The problem teaches efficient sequence generation and deduplication using pointers or indices per factor. The core idea is broadly applicable to merging k sorted lists, finding generalized number sequences, and related DP optimization problems.

### Tags
Array(#array), Math(#math), Dynamic Programming(#dynamic-programming)

### Similar Problems
- Ugly Number II(ugly-number-ii) (Medium)