### Leetcode 3337 (Hard): Total Characters in String After Transformations II [Practice](https://leetcode.com/problems/total-characters-in-string-after-transformations-ii)

### Description  
Given a string `s` of lowercase English letters, an integer `t` representing the number of transformation rounds, and an integer array `nums` of length 26, each transformation works as follows:  
For each character `s[i]` (where the 0-based index in the alphabet is c = ord(s[i]) - ord('a')), replace it by the **next** `nums[c]` consecutive characters in the alphabet, wrapping around after 'z'.  
For example, `'a'` and `nums=3` becomes `"bcd"`.  
This process is repeated for a total of `t` transformation rounds.   
Return the **total number of characters** present in the final string (after all transformations; you do NOT need the actual final string), modulo 10⁹+7.

### Examples  

**Example 1:**  
Input: `s = "ab", t = 1, nums = [3,2,...]`  
Output: `5`  
Explanation:  
- 'a' transforms to "bcd" (nums=3), 'b' to "cd" (nums[1]=2), so final string is "bcdd", hence length = 5.

**Example 2:**  
Input: `s = "y", t = 1, nums = [3,...] (nums=3)`  
Output: `3`  
Explanation:  
- 'y' transforms to "zab" (the next 3 consecutive chars after 'y' with alphabet wrap-around), so length = 3.

**Example 3:**  
Input: `s = "abc", t = 2, nums = [2,1,2,...]`  
Output: `7`  
Explanation:  
- After 1st transformation:  
  - 'a' → "bc", 'b' → "c", 'c' → "de" ⇒ string is "bccde" (length 5).
- After 2nd transformation:  
  - 'b' → "c", 'c' → "de", 'c' → "de", 'd' → "ef", 'e' → "fg" ⇒ string is "cdedefg" (length 7).

### Thought Process (as if you’re the interviewee)  

**Brute-force approach:**  
- Simulate all the transformations by creating new strings at each round.
- At every step, for each character, replace it with the corresponding next consecutive letters.
- This quickly becomes infeasible because the string size can explode exponentially, and `t` can be up to 10⁹.

**Optimized approach:**  
- **Observation:** Each character transformation depends only on the number of times it is mapped to others, not their content. This suggests a *counting* approach.
- Model the process as a **Markov chain** / linear recurrence relation: for each character, after one transformation, how many times does each other character appear?
- Create a **26×26 transition matrix**: trans[i][j] is the number of times letter 'a'+j appears when transforming letter 'a'+i **once**.
- The count after `t` transformations is just repeated application (matrix exponentiation): multiply the vector of initial character counts by (transformation matrix)^t.
    - This is fast due to the tiny dimension (26×26), so O(log t) time for matrix power.
- Only care about sum of all letter counts at the end, not string itself.

### Corner cases to consider  
- Empty string input (`s=""`): output is 0.
- `t=0`: The original string remains, so return len(s).
- nums with 0 entries: transformation produces no output for those letters.
- Full alphabet wrap-around, e.g., 'z' with nums=5.
- nums contains only 1s: every letter maps to the next single char.

### Solution

```python
MOD = 10**9 + 7

def total_characters_after_transformations(s, t, nums):
    # Base case
    if not s:
        return 0
    if t == 0:
        return len(s)
    
    # Count initial frequency of each char in s ('a'=0,...,'z'=25)
    freq = [0] * 26
    for c in s:
        freq[ord(c) - ord('a')] += 1
    
    # Build transition matrix: mat[i][j] = # of 'a'+j generated by transforming 'a'+i ONCE
    mat = [[0] * 26 for _ in range(26)]
    for i in range(26):
        n = nums[i]
        for k in range(n):
            j = (i + 1 + k) % 26  # wrap around
            mat[i][j] += 1
    
    # Matrix exponentiation: raise mat to power t
    def mat_mult(a, b):
        res = [[0] * 26 for _ in range(26)]
        for i in range(26):
            for k in range(26):
                if a[i][k]:
                    for j in range(26):
                        res[i][j] = (res[i][j] + a[i][k] * b[k][j]) % MOD
        return res

    def mat_pow(mat, power):
        res = [[int(i==j) for j in range(26)] for i in range(26)]
        while power:
            if power & 1:
                res = mat_mult(res, mat)
            mat = mat_mult(mat, mat)
            power >>= 1
        return res

    # Apply repeated transformation matrix
    mat_t = mat_pow(mat, t)

    # Final freq vector: multiply initial freq vector by mat^t
    final = [0] * 26
    for i in range(26):
        for j in range(26):
            final[j] = (final[j] + freq[i] * mat_t[i][j]) % MOD
    
    return sum(final) % MOD
```

### Time and Space complexity Analysis  

- **Time Complexity:**  
  - Counting initial frequencies: O(|s|)
  - Building 26×26 matrix: O(1)
  - Matrix exponentiation: O(26³ × log t), but with small constant since 26 is fixed (very fast).
  - Final multiplication: O(26²)
- **Space Complexity:**  
  - O(26²) for matrices and O(26) for vectors; overall O(1) w.r.t. input.

### Potential follow-up questions (as if you’re the interviewer)  

- How would you modify the solution to retrieve the **final string** instead of just the length?
  *Hint: Track the actual produced characters—a brute-force is infeasible for large t, but try with t ≤ 2 or len(s) ≤ 10.*

- Can you optimize for space if only interested in the total count, not individual letter frequencies?
  *Hint: You can reduce to a single vector; result = sum(final vector); matrix structure is still needed, but not all intermediate vectors.*

- How would the solution change if `nums` changed at each transformation?
  *Hint: Now a different matrix at each step, so you can’t power by t, instead you must multiply t different transition matrices in sequence.*

### Summary
The approach uses **matrix exponentiation** on a 26×26 character transition matrix to model repeated transformations, a powerful technique for solving recurrence-like problems on fixed-size finite states. This pattern is common in advanced combinatorial and dynamic programming settings, especially where the process can be modeled as a Markov chain or repeated function application over a finite domain.

### Tags
Hash Table(#hash-table), Math(#math), String(#string), Dynamic Programming(#dynamic-programming), Counting(#counting)

### Similar Problems
