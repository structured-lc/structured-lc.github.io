### Leetcode 502 (Hard): IPO [Practice](https://leetcode.com/problems/ipo)

### Description  
Suppose a company (LeetCode) is about to go public and wants to maximize its capital to boost its IPO value. LeetCode can only complete at most k projects before the IPO. Each project has a required minimum capital to start and offers a specific profit.  
Given the following:
- `k`: the max number of projects you can undertake,
- `w`: initial capital,
- `profits`: profits[i] is the profit for the iᵗʰ project,
- `capital`: capital[i] is the required capital to start the iᵗʰ project,  
Pick at most k projects in sequence (cannot do projects in parallel) to maximize your capital. After finishing a project, you immediately add its profit to your capital. Return the maximum capital you can achieve.

### Examples  

**Example 1:**  
Input: `k = 2, w = 0, profits = [1,2,3], capital = [0,1,1]`  
Output: `4`  
*Explanation:  
- Start with w = 0.  
- Can pick project 0 (profit=1, capital=0): capital becomes 1.  
- Now, with capital 1, projects 1 and 2 are available (both need at most 1). Pick project 2 (profit=3): capital becomes 4 (1+3).  
- Total projects taken: 2.  
- Max capital reached: 4.*

**Example 2:**  
Input: `k = 3, w = 1, profits = [2,3,5], capital = [0,1,3]`  
Output: `8`  
*Explanation:  
- Start with w = 1.  
- Can pick projects 0 (needs 0) or 1 (needs 1). Best to pick 1 (profit=3): capital becomes 4.  
- Now, with capital 4, all projects are available.  
- The next best is project 2 (profit=5): capital becomes 9.  
- Can no longer do more, as we've reached max k or finished all projects.  
- Pick one more: project 0 (profit=2): capital becomes 11.  
- However, only at most 3 projects can be picked. Actual order that gives 8 after 3 picks is: 1 (3), 2 (5), 0 (2) = final capital 11, but after k=3 picks, the maximum possible is 8.*

**Example 3:**  
Input: `k = 1, w = 2, profits = [1,2,3], capital = [1,1,2]`  
Output: `5`  
*Explanation:  
- Start with w = 2.  
- All projects are available.  
- Take project 2 (profit 3): capital becomes 5 (2+3).*

### Thought Process (as if you’re the interviewee)  

- **Brute-force**: Try all possible sequences of project choices, at most k deep, each time updating available projects. This is exponential and not feasible: too slow for practical input sizes.

- **Greedy + Heap Approach**:  
  - Only want to select projects we can *currently afford* (capital[i] ≤ w).
  - Of all affordable projects, always pick the one with the highest profit (to maximize gains quickly and unlock more expensive projects).
  - Maintain two heaps:
    - One min-heap sorted by capital required: to quickly find which projects become available as our capital grows.
    - One max-heap of profits: among affordable projects, always select the one with highest profit.
  - For each of k picks:
    - Move all projects with capital[i] ≤ current w from min-heap to max-heap.
    - If max-heap not empty: pop the project with max profit, add to w.
    - Repeat up to k times or until no more affordable projects.

- **Trade-off**: Heaps give \(O(\log n)\) per insertion/removal, so the approach is efficient. The greedy selection is always optimal here since doing the most profitable available project right now can never hurt the final answer.

### Corner cases to consider  
- profits or capital arrays are empty.
- All capital[i] > w at start (no projects can be done).
- k = 0: can't pick any project.
- Multiple projects with the same required capital and profit.
- Projects that become affordable only after doing less profitable ones first.
- k > n.
- Negative or zero profits.

### Solution

```python
import heapq

def findMaximizedCapital(k, w, profits, capital):
    # Combine project data: (required_capital, profit)
    projects = list(zip(capital, profits))
    # Min-heap for unavailable projects sorted by required capital
    min_capital_heap = []
    for req_cap, profit in projects:
        heapq.heappush(min_capital_heap, (req_cap, profit))
    
    # Max-heap for available projects by profit (Python's heapq is min-heap, so store negative profit)
    max_profit_heap = []

    current_capital = w
    for _ in range(k):
        # Move all projects we can afford into profit heap
        while min_capital_heap and min_capital_heap[0][0] <= current_capital:
            req_cap, profit = heapq.heappop(min_capital_heap)
            heapq.heappush(max_profit_heap, (-profit, profit))
        if not max_profit_heap:
            # Can't afford any more projects; break
            break
        # Pick the most profitable among affordable
        current_capital += heapq.heappop(max_profit_heap)[1]
    return current_capital
```

### Time and Space complexity Analysis  

- **Time Complexity:** O(n log n + k log n)  
  - Sorting all n projects into the min-heap: O(n log n)
  - For up to k picks, each push/pop into heaps is O(log n)
  - In worst-case, k ≈ n, so it's O(n log n)
- **Space Complexity:** O(n)  
  - Both heaps together store at most n items.

### Potential follow-up questions (as if you’re the interviewer)  

- If two projects have the same profit and capital, can we do both?  
  *Hint: Does the project list allow repeats, or are projects unique?*

- What if some projects have negative profits?  
  *Hint: Should you ever pick a project that loses money?*

- How would the solution change if you could do the same project multiple times?  
  *Hint: Would the greedy heap strategy still work? Why or why not?*

### Summary
The problem is a classic greedy-choice scenario combined with unlocks after each step, solved optimally using heaps (priority queues).  
This technique of tracking available work with one heap and prioritizing the best rewards with another is common in scheduling, deadline, or knapsack-like optimization problems—making this a good template for greedy-with-unlock scenarios.


### Flashcard
Use two heaps: a min-heap for available projects by capital, and a max-heap for profits to always pick the most profitable affordable project.

### Tags
Array(#array), Greedy(#greedy), Sorting(#sorting), Heap (Priority Queue)(#heap-priority-queue)

### Similar Problems
- Maximum Subsequence Score(maximum-subsequence-score) (Medium)
- Maximum Elegance of a K-Length Subsequence(maximum-elegance-of-a-k-length-subsequence) (Hard)