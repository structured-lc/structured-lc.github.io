### Leetcode 15 (Medium): 3Sum [Practice](https://leetcode.com/problems/3sum)

### Description  
Given an array of integers, return all unique triplets `[nums[i], nums[j], nums[k]]` such that the sum is zero and \(i, j, k\) are all distinct indices (i.e., \(i \neq j \neq k\)).  
Each triplet in the result must be unique (no duplicate triplets, regardless of order).  
You are not allowed to use the same element twice within a triplet.

Example real-world phrasing:  
*"Given a list of numbers, can you find every group of three that add up to zero, making sure no repeats show up in your answer?"*

### Examples  

**Example 1:**  
Input: `nums = [-1, 0, 1, 2, -1, -4]`  
Output: `[[-1, -1, 2], [-1, 0, 1]]`  
*Explanation:  
Sorted: `[-4, -1, -1, 0, 1, 2]`.  
Triplets: (-1, -1, 2) sums to 0; (-1, 0, 1) also sums to 0; duplicate triplets are excluded.*

**Example 2:**  
Input: `nums = [0, 1, 1]`  
Output: `[]`  
*Explanation:  
No three numbers sum to 0.*

**Example 3:**  
Input: `nums = [0, 0, 0, 0]`  
Output: `[[0, 0, 0]]`  
*Explanation:  
There are more than three zeros, so only `[0,0,0]` is a valid triplet, but only once (no repeats).*

### Thought Process (as if you’re the interviewee)  
Let's start by brute force: three nested loops for all triples \((i, j, k)\), checking if they sum to zero and making sure to avoid repeats. That's easy to code, but way too slow (O(n³)) for large n, plus tricky to avoid duplicates.

To optimize:
- **Sort the array first**. This makes it easier to spot and skip duplicates, and enables two-pointer scanning.
- Loop `i` from 0 to n−1.
    - For each `i`, use **two pointers** (`left` at i+1, `right` at n−1) to scan for pairs whose sum with `nums[i]` is zero.
    - After finding a triplet, skip over duplicate values for both `i`, `left`, and `right` to ensure no repeated triplets make it in the answer.
- This reduces time complexity to O(n²) and space is just for the output.  
- **Why this approach:** Sorting + two-pointers is ideal for sum problems, gives O(n²) speed, and the extra work on skipping duplicates is manageable and reliable.

### Corner cases to consider  
- Array with fewer than 3 items: `[]`, `[1]`, `[0,0]`
- All zeros: `[0,0,0,0]`
- No valid triplets at all: `[1,2,3]`
- All negative or all positive numbers: `[-1,-2,-3]`, `[1,2,3]`
- Duplicates that should not be counted twice: `[-2, 0, 0, 2, 2]`
- Mixed positives and negatives, but no zeros: `[1, -1, 2, -2]`

### Solution

```python
def threeSum(nums):
    # Sort to enable two-pointer approach and easy duplicate skipping
    nums.sort()
    n = len(nums)
    result = []

    for i in range(n):
        # Skip duplicate values for the first position
        if i > 0 and nums[i] == nums[i - 1]:
            continue

        # Two-pointer search for the rest of the array
        left, right = i + 1, n - 1
        while left < right:
            s = nums[i] + nums[left] + nums[right]
            if s < 0:
                left += 1  # Need a larger value
            elif s > 0:
                right -= 1  # Need a smaller value
            else:
                result.append([nums[i], nums[left], nums[right]])
                left += 1
                right -= 1

                # Skip duplicates for second and third elements
                while left < right and nums[left] == nums[left - 1]:
                    left += 1
                while left < right and nums[right] == nums[right + 1]:
                    right -= 1

    return result
```

### Time and Space complexity Analysis  

- **Time Complexity:** O(n²)  
  - The main loop runs n times, and for each i, the inner two-pointer scan covers ≤ n elements, but skips duplicates efficiently.
- **Space Complexity:** O(1) extra (ignoring output).  
  - Only uses pointers and simple lists; no extra structures.  
  - Output can have up to O(n²) triplets in the worst case, but that's required.

### Potential follow-up questions (as if you’re the interviewer)  

- What if the array is **already sorted**?  
  *Hint: Can you remove the sorting step and adjust duplicate checks for non-adjacent elements?*

- How would you solve **4Sum** or **kSum** (any size group summing to a target)?  
  *Hint: Try generalizing the two-pointer concept recursively, handling duplicates at each level.*

- What if the array is **very large** and you only want to know if *any* triplet sums to zero, not list them all?  
  *Hint: Can you stop once any such set is found? Maybe combine hashing and faster search?*

### Summary
This problem uses the **two-pointer** and **sorting** pattern—a classic for sum and combination problems. Efficient duplicate skipping is key.  
The same approach can quickly be extended to solve **4Sum**, **kSum**, or even "two-sum" with variations; it's a cornerstone in problems involving searching for groups within an array that satisfy constraints. Understanding it builds strong foundation for subset, sum, and search problems encountered frequently in interviews and real-world practice.


### Flashcard
Sort the array, then for each index, use two pointers to find pairs that sum to zero, skipping duplicates.

### Tags
Array(#array), Two Pointers(#two-pointers), Sorting(#sorting)

### Similar Problems
- Two Sum(two-sum) (Easy)
- 3Sum Closest(3sum-closest) (Medium)
- 4Sum(4sum) (Medium)
- 3Sum Smaller(3sum-smaller) (Medium)
- Number of Arithmetic Triplets(number-of-arithmetic-triplets) (Easy)
- Minimum Sum of Mountain Triplets I(minimum-sum-of-mountain-triplets-i) (Easy)
- Minimum Sum of Mountain Triplets II(minimum-sum-of-mountain-triplets-ii) (Medium)