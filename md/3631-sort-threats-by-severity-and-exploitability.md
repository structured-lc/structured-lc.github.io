### Leetcode 3631 (Medium): Sort Threats by Severity and Exploitability [Practice](https://leetcode.com/problems/sort-threats-by-severity-and-exploitability)

### Description  
You are given a list of **threats**, where each threat is represented as an object or record with at least two integer fields: **severity** and **exploitability**. **Sort the list of threats so that:**
- Threats with higher severity come first.
- If two threats have the same severity, threats with higher exploitability come first.

Return the sorted list of threats according to these rules.

Explain this to an interviewer:  
We are given threats, each with severity and exploitability scores. We need to sort them by descending severity, breaking ties by descending exploitability.

### Examples  

**Example 1:**  
Input: `threats = [{"severity": 5, "exploitability": 10}, {"severity": 9, "exploitability": 6}, {"severity": 5, "exploitability": 3}]`  
Output: `[{"severity":9,"exploitability":6}, {"severity":5,"exploitability":10}, {"severity":5,"exploitability":3}]`  
*Explanation: Highest severity (9) comes first. Among remaining, both have severity 5, so the one with higher exploitability (10) is first.*

**Example 2:**  
Input: `threats = [{"severity": 2, "exploitability": 2}, {"severity": 2, "exploitability": 3}, {"severity": 3, "exploitability": 1}]`  
Output: `[{"severity":3,"exploitability":1}, {"severity":2,"exploitability":3}, {"severity":2,"exploitability":2}]`  
*Explanation: Severity 3 first, then for severity 2, exploitability 3 comes before 2.*

**Example 3:**  
Input: `threats = [{"severity": 1, "exploitability": 4}]`  
Output: `[{"severity": 1, "exploitability": 4}]`  
*Explanation: Only one element, so no sorting needed.*

### Thought Process (as if you're the interviewee)  
- **Brute-force:** Traverse the array and use any sorting algorithm, with a custom comparator:  
  - First compare by severity (descending), then exploitability (descending).  
- **Implementation:**  
  - In Python, implement a sorting algorithm (like selection sort or similar, if built-ins are not allowed).  
  - Use tuple comparison: for each threat, treat its (-severity, -exploitability) as the sorting key.
- **Why this approach:**  
  - Sorting by two keys is a classic problem.  
  - The constraints are not specified, but general-purpose O(n log n) sorting works for most interview-sized inputs.  
  - No special data structures are needed; careful comparator logic suffices.

### Corner cases to consider  
- Empty list input  
- All threats have identical severity and exploitability  
- Threats with large/small integer values  
- One threat in the list  
- Already sorted or reverse-sorted input

### Solution

```python
def sortThreats(threats):
    """
    Sorts threats by severity (desc), then exploitability (desc).
    Each threat is a dictionary with 'severity' and 'exploitability'.
    """
    n = len(threats)
    
    # Implementing a simple selection sort so as not to use Python built-ins
    for i in range(n):
        # Assume the ith element is the maximum in the rest of array
        max_idx = i
        for j in range(i+1, n):
            # Compare by severity first
            if threats[j]['severity'] > threats[max_idx]['severity']:
                max_idx = j
            # If severity is the same, compare exploitability
            elif (threats[j]['severity'] == threats[max_idx]['severity'] and
                  threats[j]['exploitability'] > threats[max_idx]['exploitability']):
                max_idx = j
        # Swap the found max threat to current location
        threats[i], threats[max_idx] = threats[max_idx], threats[i]
    return threats
```

### Time and Space complexity Analysis  

- **Time Complexity:** O(nÂ²), because classic selection sort is used and in the worst-case, two nested loops go over all pairs.
- **Space Complexity:** O(1) extra space (apart from input and output) since sorting is in place and only constant additional variables are used.

### Follow-up questions  
- How would you achieve O(n log n) time using a built-in or more efficient sort with a comparator function?  
- How would you adapt this if threats had additional fields to break ties, or if the sort order for some fields should be ascending?