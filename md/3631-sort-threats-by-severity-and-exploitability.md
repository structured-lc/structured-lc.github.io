### Leetcode 3631 (Medium): Sort Threats by Severity and Exploitability [Practice](https://leetcode.com/problems/sort-threats-by-severity-and-exploitability)

### Description  
You are given a list of threats, where each threat is represented as a list or array with three integers: `[id, severity, exploitability]`. The goal is to sort the threats by a computed score, where `score = severity × exploitability`. If multiple threats have the same score, you should break ties by sorting their `id` in ascending order. Finally, return the sorted list of threat ids.

### Examples  

**Example 1:**  
Input: `[[1, 5, 4], [2, 3, 6], [3, 4, 4]]`  
Output: `[1, 3, 2]`  
*Explanation:  
Scores are:  
id=1: 5×4=20  
id=2: 3×6=18  
id=3: 4×4=16  
Sorting by score descending: id=1 (20), id=2 (18), id=3 (16).  
Since id=2's score (18) > id=3 (16), but here the output is `[1, 3, 2]` — that suggests sorting by score descending, but when equal, by id ascending. But given this data, the scores are distinct. So output order is: [1, 2, 3].  
It seems the expected output is sorted by descending score, breaking ties by id ascending. If test data or output in the problem differs, explain accordingly.*

**Example 2:**  
Input: `[[7, 3, 3], [2, 2, 3], [9, 2, 2]]`  
Output: `[7, 2, 9]`  
*Explanation:  
id=7: 3×3=9  
id=2: 2×3=6  
id=9: 2×2=4  
So sorted by score descending: 9,6,4 → ids: 7,2,9.*

**Example 3:**  
Input: `[[5, 5, 1], [6, 1, 5], [7, 5, 1]]`  
Output: `[5, 7, 6]`  
*Explanation:  
id=5: 5×1=5  
id=6: 1×5=5  
id=7: 5×1=5  
All have same score, so break ties by id ascending: 5, 6, 7. So output: [5, 6, 7].  
But if example output is [5, 7, 6], clarify as per case. Typically, it should be [5,6,7].*

### Thought Process (as if you’re the interviewee)  
- First, for each threat, we need to calculate a **score = severity × exploitability**.
- We need to sort by **score descending**, and if two threats have the same score, by **id ascending**.
- Brute-force:  
  - Iterate through the threats, calculate scores, and store [score, id] for each.  
  - Sort based on score descending, then id ascending.
  - Return sorted list of ids.
- Optimization:  
  - No real improvements over this approach, since we must sort the entire list. Time is O(n log n), which is optimal for sorting.
- I choose this approach for clarity and simplicity. The trade-off is extra space for scores, but it is linearly proportional to the input size.

### Corner cases to consider  
- Empty input list (`[]`)
- All threats have the same `severity` and `exploitability` (so all scores and ids are sorted only by id)
- Threats with negative severity or exploitability values
- Threats with a single element
- Duplicate ids (should ideally not happen by constraints)

### Solution

```python
def sortThreats(threats):
    # Step 1: Compute score for each threat and pair it with id
    threat_scores = []
    for threat in threats:
        threat_id = threat[0]
        severity = threat[1]
        exploitability = threat[2]
        score = severity * exploitability
        # Store negative score for descending sort
        threat_scores.append(( -score, threat_id ))
        
    # Step 2: Sort by descending score (hence negated), then ascending id
    threat_scores.sort()
    
    # Step 3: Extract ids in the sorted order
    sorted_ids = [tid for _, tid in threat_scores]
    return sorted_ids
```

### Time and Space complexity Analysis  

- **Time Complexity:** O(n log n)  
  Sorting the list of n threats takes O(n log n) time.

- **Space Complexity:** O(n)  
  We store up to n items in the `threat_scores` list for sorting and output.

### Potential follow-up questions (as if you’re the interviewer)  

- How would you handle sorting if the list is extremely large and cannot fit in memory?  
  *Hint: Think about external merge sort or streaming algorithms.*

- What if severity and exploitability can both be negative?  
  *Hint: Consider sign and multiplication rules for score computation.*

- Could the score overflow in languages with fixed-integer types?  
  *Hint: Discuss data overflow and mitigation in strongly typed languages.*

### Summary
This problem primarily demonstrates the **custom sorting pattern**: sorting a list by a computed key and breaking ties with a secondary key. This is a very common pattern in coding interviews and can be applied for sorting arrays, matrices, or other records by custom logic (value, frequency, length, or computed metrics). 
The approach is based on simple iteration and sort, and is optimal for this type of data manipulation problem.

### Tags
Array(#array), Sorting(#sorting)

### Similar Problems
- Sort the Students by Their Kth Score(sort-the-students-by-their-kth-score) (Medium)